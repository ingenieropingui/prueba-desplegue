{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nimport scrapedEvents from '../data/scraped_events.json';\n\n// Build an indexed structure eventsData[City][Category] => [events]\n// helper: if the imported JSON is already hierarchical ([{ciudad, categoria, eventos: []}, ...])\n// normalize it into the eventsData structure. Otherwise fall back to the flat-array builder.\nfunction inferCityFromEvent(e) {\n  const url = (e.url || '').toLowerCase();\n  if ((e.source || '').toLowerCase().includes('pablotobon') || url.includes('medellin') || url.includes('medell')) return 'MedellÃ­n';\n  if ((e.source || '').toLowerCase().includes('astor') || url.includes('bogota') || url.includes('bogot')) return 'BogotÃ¡';\n  if (url.includes('cali')) return 'Cali';\n  if (url.includes('bucaramanga')) return 'Bucaramanga';\n  if (url.includes('cartagena')) return 'Cartagena';\n  if (url.includes('barranquilla')) return 'Barranquilla';\n  // fallback unknown\n  return 'BogotÃ¡';\n}\nfunction inferCategoryFromEvent(e) {\n  const text = ((e.tipo || '') + ' ' + (e.nombre || e.titulo || '') + ' ' + (e.descripcion || '')).toLowerCase();\n  if (text.match(/m(usica|Ãºsica)|conciert|band|orquesta|cantante|cantor/)) return 'MÃºsica';\n  if (text.match(/teatro|obra|drama|monÃ³logo|monolog/)) return 'Culturales';\n  if (text.match(/conferencia|congreso|foro|seminar|seminario|charla/)) return 'Conferencias';\n  if (text.match(/deporte|futbol|baloncesto|carrera|maraton|marat[oÃ³]n/)) return 'Deportes';\n  // fallback: if tipo field suggests teatro vs musica\n  const tipo = (e.tipo || '').toLowerCase();\n  if (tipo.includes('mus') || tipo.includes('mÃºsica')) return 'MÃºsica';\n  if (tipo.includes('teatro')) return 'Culturales';\n  return 'Culturales';\n}\nfunction buildEventsIndex(arr) {\n  const out = {};\n  arr.forEach(raw => {\n    const city = inferCityFromEvent(raw);\n    const category = inferCategoryFromEvent(raw);\n    // keep original fields but normalize common aliases and ensure url/lugar exist\n    const ev = Object.assign({}, raw);\n    ev.nombre = raw.nombre || raw.titulo || ev.nombre || '';\n    ev.fecha = raw.fecha || ev.fecha || null;\n    ev.hora = raw.hora || ev.hora || null;\n    ev.lugar = raw.lugar || raw.ubicacion || ev.lugar || '' || '';\n    ev.descripcion = raw.descripcion || raw.summary || ev.descripcion || '';\n    ev.url = raw.url || raw.link || ev.url || '';\n    out[city] = out[city] || {};\n    out[city][category] = out[city][category] || [];\n    out[city][category].push(ev);\n  });\n  return out;\n}\n\n// New: accept two possible source shapes:\n// 1) flat array of event objects -> buildEventsIndex(flatArray)\n// 2) hierarchical array like the attached `scrapers.json` where each item has\n//    { ciudad: 'Name', categoria: 'Cat', eventos: [ ... ] }\nfunction buildEventsIndexFromSource(src) {\n  // detect hierarchical structure\n  if (Array.isArray(src) && src.length > 0 && src[0] && (src[0].ciudad || src[0].categoria) && src[0].eventos) {\n    const out = {};\n    src.forEach(block => {\n      const city = block.ciudad || capitalizeFirst(block.city || '');\n      const category = block.categoria || block.category || 'General';\n      out[city] = out[city] || {};\n      out[city][category] = out[city][category] || [];\n      const list = Array.isArray(block.eventos) ? block.eventos : block.events || [];\n      list.forEach(raw => {\n        const ev = Object.assign({}, raw);\n        ev.nombre = raw.nombre || raw.titulo || ev.nombre || '';\n        ev.fecha = raw.fecha || ev.fecha || null;\n        ev.hora = raw.hora || ev.hora || null;\n        ev.lugar = raw.lugar || raw.ubicacion || ev.lugar || '' || '';\n        ev.descripcion = raw.descripcion || raw.summary || ev.descripcion || '';\n        ev.url = raw.url || raw.link || ev.url || '';\n        out[city][category].push(ev);\n      });\n    });\n    return out;\n  }\n\n  // fallback: flat array of events\n  return buildEventsIndex(src || []);\n}\nconst eventsData = buildEventsIndexFromSource(scrapedEvents || []);\nimport { genId, formatDate, parseIntent, sleep } from '../utils/chatHelpers';\n\n// NOTE: Do not change selector names or external classes. This module is pure logic.\n\n// Derivar dinÃ¡micamente las ciudades y categorÃ­as a partir de los datos scrapeados\nfunction getCities() {\n  return Object.keys(eventsData).sort();\n}\nfunction getCategoriesForCity(city) {\n  if (!city) return [];\n  return Object.keys(eventsData[city] || {}).sort();\n}\nexport function useChatBot() {\n  _s();\n  const PAGE_SIZE = 5; // configurable page size (mostrar X por acciÃ³n) â€” ahora mostramos varios eventos por peticiÃ³n\n\n  const [open, setOpen] = useState(true);\n  const [state, setState] = useState('idle'); // idle | esperandoCiudad | esperandoCategoria | mostrandoEventos\n  const [selectedCity, setSelectedCity] = useState(null);\n  const [selectedCategory, setSelectedCategory] = useState(null);\n  const [messages, setMessages] = useState(() => [{\n    id: genId('msg'),\n    sender: 'ia',\n    text: 'Â¡Hola! Soy tu asistente de eventos â€” encantado de ayudarte. Â¿En quÃ© ciudad te gustarÃ­a buscar?',\n    time: new Date().toISOString()\n  }]);\n  const [isTyping, setIsTyping] = useState(false);\n\n  // pagination index per city|category key\n  const [pages, setPages] = useState({});\n  // keep a pending city context when bot asked for category but selectedCity may not be set yet\n  const [pendingCity, setPendingCity] = useState(null);\n  const pushMessage = useCallback((sender, text) => {\n    const msg = {\n      id: genId('msg'),\n      sender,\n      text,\n      time: new Date().toISOString()\n    };\n    setMessages(m => [...m, msg]);\n    return msg;\n  }, []);\n\n  // Helper to simulate typing and then send one or multiple bot messages\n  const botReply = useCallback((items = [], delay = 600) => {\n    // items: array of message objects to push after typing\n    (async () => {\n      setIsTyping(true);\n      // push typing indicator (UI will render the animated dots)\n      const typingId = genId('typing');\n      setMessages(m => [...m, {\n        id: typingId,\n        sender: 'ia',\n        type: 'typing',\n        text: 'Un momento, busco lo mejor para ti ðŸ˜Š'\n      }]);\n      await sleep(delay);\n      // remove typing indicator and append items\n      setMessages(prev => prev.filter(x => x.id !== typingId).concat(items.map(it => ({\n        id: genId('msg'),\n        sender: 'ia',\n        ...it,\n        time: new Date().toISOString()\n      }))));\n      setIsTyping(false);\n    })();\n  }, []);\n  const listCities = useCallback(() => {\n    setState('esperandoCiudad');\n    // send a text prompt listing cities (conversational, user must type the city name)\n    const cities = getCities();\n    botReply([{\n      text: `Selecciona una ciudad: ${cities.join(', ')}. Escribe el nombre de la ciudad para continuar.`\n    }], 700);\n  }, [pushMessage]);\n  const listCategories = useCallback(city => {\n    setState('esperandoCategoria');\n    setPendingCity(city);\n    const cats = getCategoriesForCity(city);\n    const catsText = cats.length ? cats.join(', ') : 'No hay categorÃ­as predefinidas para esta ciudad; puedes escribir palabras como MÃºsica, Teatro, Deportes.';\n    botReply([{\n      text: `Has seleccionado ${city}. Â¿QuÃ© categorÃ­a quieres ver? ${catsText}. Escribe la categorÃ­a.`\n    }], 700);\n  }, [pushMessage]);\n  const showEvents = useCallback((city, category) => {\n    setState('mostrandoEventos');\n    setSelectedCity(city);\n    setSelectedCategory(category);\n    const key = `${city}|${category}`;\n    const cityData = eventsData[city] || {};\n    const list = cityData[category] || [];\n\n    // initialize page index if needed\n    setPages(p => ({\n      ...p,\n      [key]: p[key] ? p[key] : 0\n    }));\n    if (list.length === 0) {\n      botReply([{\n        text: `Ups â€” no encuentro ${category} en ${city} ahora mismo. Puedes escribir otra ciudad, otra categorÃ­a, o \"volver\" para reiniciar.`\n      }], 600);\n      return;\n    }\n\n    // show PAGE_SIZE items starting from pages[key]\n    // read current page index from state (pages may have been initialized above)\n    const start = pages[key] || 0;\n    const slice = list.slice(start, start + PAGE_SIZE);\n    const items = [];\n    // Use a neutral, non-counting intro to avoid revealing small totals.\n    items.push({\n      text: `AquÃ­ tienes algunos eventos en ${category} Â· ${city}:`\n    });\n    slice.forEach(ev => {\n      // return the full event object as stored in the index, but format fecha\n      const formatted = Object.assign({}, ev);\n      try {\n        formatted.fecha = formatDate(ev.fecha);\n      } catch (err) {\n        formatted.fecha = ev.fecha || null;\n      }\n      items.push({\n        type: 'event',\n        payload: formatted\n      });\n    });\n    // guidance for next steps (conversational)\n    const guidance = [];\n    if (start + PAGE_SIZE < list.length) guidance.push('Si quieres ver mÃ¡s, escribe \"ver mÃ¡s\".');\n    guidance.push('Para cambiar de ciudad escribe el nombre de la ciudad. Escribe \"volver\" para volver al inicio.');\n    items.push({\n      text: guidance.join(' ')\n    });\n    botReply(items, 800);\n  }, [pushMessage]);\n  // note: showEvents depends on pages state (used to compute start index). We rely\n  // on reading `pages` directly inside the callback so include it in the dependency\n  // chain where this hook is recreated when pages changes. To avoid linter noise\n  // we could list [pushMessage, pages], but we intentionally keep the body simple\n  // and update pages via setPages when advancing. If you see stale page indices,\n  // we can refactor to accept an explicit page offset parameter.\n\n  const handleText = useCallback(text => {\n    if (!text || !text.trim()) return;\n    const t = text.trim();\n    pushMessage('user', t);\n    // use parseIntent from helpers\n    const intent = parseIntent(t);\n\n    // If parser returned a confidence score, use it to decide clarifications\n    const confidence = typeof intent.confidence === 'number' ? intent.confidence : 1.0;\n\n    // Merge parsed city/category into conversation state (do not overwrite existing unless explicit change requested)\n    const parsedCity = intent.city || null;\n    const parsedCategory = intent.category || null;\n\n    // helpers to map parsed tokens into canonical keys used by eventsData\n    function mapCity(raw) {\n      if (!raw) return null;\n      // prefer normalizeCityName if it maps\n      const byName = normalizeCityName(raw);\n      if (byName && eventsData[byName]) return byName;\n      const target = normalizeString(raw);\n      for (const k of Object.keys(eventsData)) {\n        if (normalizeString(k).startsWith(target)) return k;\n      }\n      return byName || capitalizeFirst(raw);\n    }\n    function mapCategory(raw, cityForLookup) {\n      if (!raw) return null;\n      // if we have a city, prefer finding a category key within that city\n      if (cityForLookup) {\n        const found = findCategoryKeyForCity(cityForLookup, raw);\n        if (found) return found;\n      }\n      // otherwise search globally across cities for a matching category key\n      const target = normalizeString(raw);\n      for (const cityKey of Object.keys(eventsData)) {\n        const cats = Object.keys(eventsData[cityKey] || {});\n        for (const c of cats) {\n          if (normalizeString(c).startsWith(target) || normalizeString(c) === target) return c;\n        }\n      }\n      // fallback: return capitalized raw\n      return capitalizeFirst(raw);\n    }\n\n    // Determine mapped values (do not commit to state yet)\n    const mappedCity = parsedCity ? mapCity(parsedCity) : null;\n    const mappedCategory = parsedCategory ? mapCategory(parsedCategory, mappedCity || selectedCity) : null;\n\n    // detect explicit change request keywords in user's message (approximate)\n    const lowerRaw = (t || '').toLowerCase();\n    const explicitChange = /\\b(cambiar|cambio|cambia|nuevo|otra ciudad|otra categoria|otra categorÃ­a|cambiar a)\\b/.test(lowerRaw);\n\n    // Apply parsed city if we don't have one yet or user explicitly asked to change\n    if (mappedCity) {\n      if (!selectedCity) {\n        setSelectedCity(mappedCity);\n      } else if (selectedCity !== mappedCity && explicitChange) {\n        setSelectedCity(mappedCity);\n      }\n    }\n\n    // Apply parsed category if we don't have one yet or user explicitly asked to change\n    if (mappedCategory) {\n      if (!selectedCategory) {\n        setSelectedCategory(mappedCategory);\n      } else if (selectedCategory !== mappedCategory && explicitChange) {\n        setSelectedCategory(mappedCategory);\n      }\n    }\n\n    // If after applying parsed tokens we have both city and category, perform immediate search\n    const finalCity = mappedCity || selectedCity;\n    const finalCategory = mappedCategory || selectedCategory;\n    if (finalCity && finalCategory) {\n      // ensure pagination cursor reset for this pair\n      const key = `${finalCity}|${finalCategory}`;\n      setPages(p => ({\n        ...p,\n        [key]: 0\n      }));\n      setSelectedCity(finalCity);\n      setSelectedCategory(finalCategory);\n      // Show first event immediately\n      botReply([{\n        text: `Perfecto â€” buscando ${finalCategory} en ${finalCity}...`\n      }], 400);\n      // slight delay then show events (showEvents will simulate typing too)\n      setTimeout(() => showEvents(finalCity, finalCategory), 600);\n      return;\n    }\n\n    // If user typed a city name as free text, map to a known city using eventsData\n    if (!mappedCity && !selectedCity) {\n      // try to match raw text to a city present in eventsData\n      const candidate = Object.keys(eventsData).find(k => normalizeString(k) === normalizeString(t) || normalizeString(k).startsWith(normalizeString(t)));\n      if (candidate) {\n        // ask for category for that city\n        listCategories(candidate);\n        return;\n      }\n    }\n\n    // If we only have category, ask for city\n    if ((mappedCategory || selectedCategory) && !(mappedCity || selectedCity)) {\n      const catToAsk = mappedCategory || selectedCategory;\n      botReply([{\n        text: `Â¿En quÃ© ciudad quieres buscar ${catToAsk}? Por ejemplo BogotÃ¡, MedellÃ­n, Cali o Bucaramanga.`\n      }], 500);\n      return;\n    }\n\n    // If we only have city, ask for category\n    if ((mappedCity || selectedCity) && !(mappedCategory || selectedCategory)) {\n      const cityToAsk = mappedCity || selectedCity;\n      botReply([{\n        text: `Genial â€” Â¿quÃ© categorÃ­a te interesa en ${cityToAsk} (por ejemplo MÃºsica, Deportes, Culturales)?`\n      }], 500);\n      return;\n    }\n    if (intent.intent === 'list_cities') {\n      listCities();\n      return;\n    }\n    // greetings -> friendly human reply and open question\n    if (intent.intent === 'greeting') {\n      botReply([{\n        text: 'Â¡Hola! ðŸ˜Š Â¿En quÃ© ciudad te gustarÃ­a buscar eventos o escribe \"buscar <texto>\" para una bÃºsqueda rÃ¡pida?'\n      }], 500);\n      return;\n    }\n    if (intent.intent === 'help') {\n      botReply([{\n        text: 'Puedo ayudarte a encontrar eventos. Prueba escribir: \"ver ciudades\", \"buscar <texto>\", el nombre de una ciudad (p.e. BogotÃ¡), \"ver mÃ¡s\" o \"volver\" para reiniciar.'\n      }], 600);\n      return;\n    }\n    // user asked to see events -> start the city selection flow\n    if (intent.intent === 'list_events') {\n      listCities();\n      return;\n    }\n    if (intent.intent === 'restart') {\n      restart();\n      return;\n    }\n    if (intent.intent === 'show_more') {\n      selectOption('showMore');\n      return;\n    }\n    if (intent.intent === 'search_query') {\n      // show intermediate typing message\n      botReply([{\n        text: `Perfecto â€” busco \"${intent.query}\"...`\n      }], 500);\n      // do a search across events and show first match (paged)\n      const q = intent.query.toLowerCase();\n      const results = [];\n      Object.keys(eventsData).forEach(city => {\n        Object.keys(eventsData[city]).forEach(cat => {\n          eventsData[city][cat].forEach(ev => {\n            const hay = `${ev.nombre} ${ev.artista || ''} ${ev.lugar || ''} ${ev.descripcion || ''}`.toLowerCase();\n            if (hay.includes(q)) results.push({\n              city,\n              category: cat,\n              event: ev\n            });\n          });\n        });\n      });\n      if (results.length === 0) {\n        botReply([{\n          text: `No encontrÃ© nada para \"${intent.query}\". Â¿Quieres que muestre ciudades, intentes otra bÃºsqueda o pidas ayuda? Escribe ver ciudades, buscar <texto> o ayuda.`\n        }], 800);\n      } else {\n        // show first found as event (and set pagination state for that city|category)\n        const r = results[0];\n        const city = capitalizeFirst(r.city);\n        const cat = capitalizeFirst(r.category);\n        // set pages index so showMore continues in that list\n        const key = `${city}|${cat}`;\n        setPages(p => ({\n          ...p,\n          [key]: 0\n        }));\n        botReply([{\n          text: `Resultado para \"${intent.query}\" en ${city} â€” ${cat}:`\n        }, {\n          type: 'event',\n          payload: {\n            ...r.event,\n            fecha: formatDate(r.event.fecha)\n          }\n        }, {\n          text: 'Escribe \"ver mÃ¡s\" para ver otro resultado, o \"volver\" para reiniciar.'\n        }], 700);\n      }\n      return;\n    }\n    if (intent.intent === 'search') {\n      // robust mapping: normalize keys (remove accents) and match\n      const wantedCity = normalizeString(intent.city);\n      const wantedCat = normalizeString(intent.category);\n      let cityKey = null;\n      for (const k of Object.keys(eventsData)) {\n        if (normalizeString(k).startsWith(wantedCity)) {\n          cityKey = k;\n          break;\n        }\n      }\n      let categoryKey = null;\n      if (cityKey) {\n        categoryKey = findCategoryKeyForCity(cityKey, intent.category) || Object.keys(eventsData[cityKey]).find(k => normalizeString(k).startsWith(wantedCat));\n      }\n      if (cityKey && categoryKey) {\n        // show first event and setup pagination for the proper key names\n        const catDisplay = categoryKey;\n        const pageKey = `${cityKey}|${catDisplay}`;\n        setPages(p => ({\n          ...p,\n          [pageKey]: 0\n        }));\n        setSelectedCity(cityKey);\n        setSelectedCategory(catDisplay);\n        showEvents(cityKey, catDisplay);\n      } else {\n        const cityPretty = capitalizeFirst(intent.city);\n        const catPretty = capitalizeFirst(intent.category);\n        botReply([{\n          text: `Lo siento â€” no tengo toda la info exacta para ${cityPretty} y ${catPretty} ahora mismo. Escribe \"ver ciudades\" para ver opciones o intenta otra bÃºsqueda.`\n        }], 600);\n      }\n      return;\n    }\n    if (intent.intent === 'choose_city') {\n      // normalize incoming city name\n      const rawCity = intent.city;\n      const city = capitalizeFirst(rawCity);\n\n      // If we already had a selected city, user is switching city mid-conversation\n      if (selectedCity && selectedCity !== city) {\n        // Attempt to preserve category filter if possible\n        if (selectedCategory) {\n          const validCat = findCategoryKeyForCity(city, selectedCategory);\n          if (validCat) {\n            // Reset pagination for new city+category then show first page\n            const key = `${city}|${validCat}`;\n            setPages(p => ({\n              ...p,\n              [key]: 0\n            }));\n            setSelectedCity(city);\n            setSelectedCategory(validCat);\n            botReply([{\n              text: `Perfecto â€” ahora busco eventos en ${city}. Mantengo la categorÃ­a ${validCat}.`\n            }], 600);\n            // show first item\n            showEvents(city, validCat);\n            return;\n          } else {\n            // category not available in new city: inform and offer alternatives\n            setSelectedCity(city);\n            setSelectedCategory(null);\n            const available = getCategoriesForCity(city);\n            const options = available.length ? available.concat(['Ver todos']) : ['MÃºsica', 'Culturales', 'Deportes', 'Conferencias'];\n            botReply([{\n              text: `CambiÃ© a ${city}, pero no encontrÃ© la categorÃ­a ${selectedCategory} allÃ­.`\n            }, {\n              text: `Puedes elegir otra categorÃ­a: ${options.join(', ')}. Escribe la categorÃ­a que prefieras.`\n            }], 700);\n            return;\n          }\n        }\n        // No category to preserve â€” just update city and ask what to do next\n        setSelectedCity(city);\n        setPendingCity(null);\n        const cityCats = getCategoriesForCity(city);\n        const catsText = cityCats.length ? cityCats.join(', ') : 'MÃºsica, Culturales, Deportes, Conferencias';\n        botReply([{\n          text: `Perfecto â€” ahora busco eventos en ${city}. Â¿QuÃ© categorÃ­a te interesa? ${catsText}. Escribe la categorÃ­a.`\n        }], 600);\n        return;\n      }\n\n      // default behavior (no selectedCity previously): show categories for chosen city\n      listCategories(city);\n      return;\n    }\n    if (intent.intent === 'choose_category') {\n      const rawCat = intent.category;\n      // find a valid category key in the currently selected city or pendingCity\n      const cityForLookup = selectedCity || pendingCity;\n      const validCat = cityForLookup ? findCategoryKeyForCity(cityForLookup, rawCat) : null;\n      if (validCat && cityForLookup) {\n        // reset pagination for this city|category\n        const key = `${cityForLookup}|${validCat}`;\n        setPages(p => ({\n          ...p,\n          [key]: 0\n        }));\n        setSelectedCategory(validCat);\n        setSelectedCity(cityForLookup);\n        showEvents(cityForLookup, validCat);\n      } else if (selectedCity && !validCat) {\n        // selected city exists but category not found there\n        const available = getCategoriesForCity(selectedCity);\n        const options = available.length ? available.concat(['Ver todos']) : ['MÃºsica', 'Culturales', 'Deportes', 'Conferencias'];\n        botReply([{\n          text: `No encontrÃ© la categorÃ­a solicitada en ${selectedCity}. Puedes elegir otra categorÃ­a: ${options.join(', ')}. Escribe la que prefieras.`\n        }], 600);\n      } else {\n        const cities = getCities();\n        botReply([{\n          text: `Has pedido la categorÃ­a ${capitalizeFirst(rawCat)}. Primero, selecciona una ciudad: ${cities.join(', ')}. Escribe la ciudad.`\n        }], 600);\n      }\n      return;\n    }\n    // fallback: use confidence to decide whether to clarify or perform a best-effort\n    if (confidence < 0.6) {\n      botReply([{\n        text: 'No estoy seguro de quÃ© quieres decir â€” Â¿Quieres que muestre ciudades, buscar por texto o ver ayuda? Escribe \"ver ciudades\", \"buscar <texto>\" o \"ayuda\".'\n      }], 600);\n    } else {\n      // try a friendly fallback that asks a clarifying question\n      botReply([{\n        text: 'Â¿Quieres que muestre ciudades, busque por texto o te muestre ayuda? Escribe ver ciudades, buscar <texto> o ayuda.'\n      }], 600);\n    }\n  }, [listCities, listCategories, pushMessage, selectedCity, showEvents]);\n\n  // API requested: sendText, selectOption, resetConversation\n  const sendText = useCallback(text => {\n    handleText(text);\n  }, [handleText]);\n  const selectOption = useCallback((type, value) => {\n    // type: 'city'|'category'|'action'|'showMore'\n    if (type === 'city') {\n      selectCity(value);\n      return;\n    }\n    if (type === 'category') {\n      selectCategory(value);\n      return;\n    }\n    if (type === 'action' && (value || '').toLowerCase().includes('volver')) {\n      restart();\n      return;\n    }\n    if (type === 'showMore' || type === 'action' && (value || '').toLowerCase().includes('ver m')) {\n      // advance pagination for current selection\n      const city = selectedCity;\n      const category = selectedCategory;\n      if (!city || !category) {\n        botReply([{\n          text: 'Primero selecciona una ciudad y categorÃ­a. Escribe \"ver ciudades\" para ver la lista de ciudades.'\n        }], 500);\n        return;\n      }\n      const key = `${city}|${category}`;\n      const cityData = eventsData[city] || {};\n      const list = cityData[category] || [];\n      const current = pages[key] || 0;\n      const next = current + PAGE_SIZE;\n      if (next >= list.length) {\n        botReply([{\n          text: `No hay mÃ¡s eventos en ${category} para ${city}. Puedes escribir otra categorÃ­a o ciudad, o \"volver\" para reiniciar.`\n        }], 600);\n        return;\n      }\n      // advance page index then show next PAGE_SIZE items\n      setPages(p => ({\n        ...p,\n        [key]: next\n      }));\n      // show events from next index\n      const slice = list.slice(next, next + PAGE_SIZE);\n      const items = [{\n        text: `AquÃ­ tienes mÃ¡s eventos en ${category} Â· ${city}:`\n      }];\n      slice.forEach(ev => items.push({\n        type: 'event',\n        payload: {\n          ...ev,\n          fecha: formatDate(ev.fecha)\n        }\n      }));\n      items.push({\n        text: next + PAGE_SIZE < list.length ? 'Escribe \"ver mÃ¡s\" para seguir viendo eventos.' : 'No quedan mÃ¡s eventos en esta lista. Escribe otra categorÃ­a o ciudad, o \"volver\".'\n      });\n      botReply(items, 700);\n      return;\n    }\n  }, [listCategories, pushMessage, showEvents, selectedCity, selectedCategory, pages, PAGE_SIZE, botReply]);\n\n  // helper functions local to hook\n  function capitalizeFirst(s) {\n    if (!s) return s;\n    return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();\n  }\n  function normalizeString(s) {\n    if (!s) return '';\n    return s.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').trim();\n  }\n  function normalizeCityName(raw) {\n    if (!raw) return raw;\n    const r = raw.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n    if (r.startsWith('medell')) return 'MedellÃ­n';\n    if (r.startsWith('bogo')) return 'BogotÃ¡';\n    if (r.startsWith('cali')) return 'Cali';\n    if (r.startsWith('bucara')) return 'Bucaramanga';\n    if (r.startsWith('cart') || r.startsWith('cartag')) return 'Cartagena';\n    if (r.startsWith('barra') || r.startsWith('barran')) return 'Barranquilla';\n    return raw;\n  }\n\n  // find a category key in a city by comparing normalized strings (handles accents)\n  function findCategoryKeyForCity(city, catLike) {\n    if (!city || !catLike) return null;\n    const cityData = eventsData[city] || {};\n    const cats = Object.keys(cityData || {});\n    const target = catLike.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n    for (const k of cats) {\n      const nk = k.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n      if (nk === target || nk.startsWith(target)) return k;\n    }\n    return null;\n  }\n  const selectCity = useCallback(city => {\n    if (!city) return;\n    setSelectedCity(city);\n    listCategories(city);\n  }, [listCategories]);\n  const selectCategory = useCallback(category => {\n    if (!category) return;\n    const cityToUse = selectedCity || pendingCity;\n    if (!cityToUse) {\n      pushMessage('ia', 'Primero, elige una ciudad para buscar.');\n      listCities();\n      return;\n    }\n    // clear pendingCity after consuming\n    setPendingCity(null);\n    showEvents(cityToUse, category);\n  }, [selectedCity, pendingCity, pushMessage, listCities, showEvents]);\n  const restart = useCallback(() => {\n    setState('idle');\n    setSelectedCity(null);\n    setSelectedCategory(null);\n    setMessages([{\n      id: genId('msg'),\n      sender: 'ia',\n      text: 'Â¡Hola de nuevo! Dime en quÃ© ciudad buscas y preparo algunas opciones para ti.',\n      time: new Date().toISOString()\n    }]);\n  }, []);\n  const toggleOpen = useCallback(() => setOpen(o => !o), []);\n  return {\n    open,\n    state,\n    selectedCity,\n    selectedCategory,\n    messages,\n    isTyping,\n    // API methods requested\n    sendText: sendText,\n    selectOption: selectOption,\n    resetConversation: restart,\n    toggleOpen,\n    // legacy actions object for UI compatibility\n    actions: {\n      pushMessage,\n      handleText,\n      listCities,\n      listCategories,\n      selectCity,\n      selectCategory,\n      showEvents,\n      restart,\n      toggleOpen,\n      // expose newer API on actions for backward compatibility\n      selectOption,\n      sendText,\n      resetConversation: restart\n    }\n  };\n}\n_s(useChatBot, \"FJDbS/sQPybzCwr2pg9vQBXnAi8=\");\nexport default useChatBot;","map":{"version":3,"names":["useState","useCallback","scrapedEvents","inferCityFromEvent","e","url","toLowerCase","source","includes","inferCategoryFromEvent","text","tipo","nombre","titulo","descripcion","match","buildEventsIndex","arr","out","forEach","raw","city","category","ev","Object","assign","fecha","hora","lugar","ubicacion","summary","link","push","buildEventsIndexFromSource","src","Array","isArray","length","ciudad","categoria","eventos","block","capitalizeFirst","list","events","eventsData","genId","formatDate","parseIntent","sleep","getCities","keys","sort","getCategoriesForCity","useChatBot","_s","PAGE_SIZE","open","setOpen","state","setState","selectedCity","setSelectedCity","selectedCategory","setSelectedCategory","messages","setMessages","id","sender","time","Date","toISOString","isTyping","setIsTyping","pages","setPages","pendingCity","setPendingCity","pushMessage","msg","m","botReply","items","delay","typingId","type","prev","filter","x","concat","map","it","listCities","cities","join","listCategories","cats","catsText","showEvents","key","cityData","p","start","slice","formatted","err","payload","guidance","handleText","trim","t","intent","confidence","parsedCity","parsedCategory","mapCity","byName","normalizeCityName","target","normalizeString","k","startsWith","mapCategory","cityForLookup","found","findCategoryKeyForCity","cityKey","c","mappedCity","mappedCategory","lowerRaw","explicitChange","test","finalCity","finalCategory","setTimeout","candidate","find","catToAsk","cityToAsk","restart","selectOption","query","q","results","cat","hay","artista","event","r","wantedCity","wantedCat","categoryKey","catDisplay","pageKey","cityPretty","catPretty","rawCity","validCat","available","options","cityCats","rawCat","sendText","value","selectCity","selectCategory","current","next","s","charAt","toUpperCase","normalize","replace","catLike","nk","cityToUse","toggleOpen","o","resetConversation","actions"],"sources":["C:/Users/crist/OneDrive/Documents/Clonado fronted despliegue/prueba-desplegue/Proyecto-Integrador-fronted-main/src/components/ChatBotLogic.jsx"],"sourcesContent":["import { useState, useCallback } from 'react';\r\nimport scrapedEvents from '../data/scraped_events.json';\r\n\r\n// Build an indexed structure eventsData[City][Category] => [events]\r\n// helper: if the imported JSON is already hierarchical ([{ciudad, categoria, eventos: []}, ...])\r\n// normalize it into the eventsData structure. Otherwise fall back to the flat-array builder.\r\nfunction inferCityFromEvent(e) {\r\n  const url = (e.url || '').toLowerCase();\r\n  if ((e.source || '').toLowerCase().includes('pablotobon') || url.includes('medellin') || url.includes('medell')) return 'MedellÃ­n';\r\n  if ((e.source || '').toLowerCase().includes('astor') || url.includes('bogota') || url.includes('bogot')) return 'BogotÃ¡';\r\n  if (url.includes('cali')) return 'Cali';\r\n  if (url.includes('bucaramanga')) return 'Bucaramanga';\r\n  if (url.includes('cartagena')) return 'Cartagena';\r\n  if (url.includes('barranquilla')) return 'Barranquilla';\r\n  // fallback unknown\r\n  return 'BogotÃ¡';\r\n}\r\n\r\nfunction inferCategoryFromEvent(e) {\r\n  const text = ((e.tipo || '') + ' ' + (e.nombre || e.titulo || '') + ' ' + (e.descripcion || '')).toLowerCase();\r\n  if (text.match(/m(usica|Ãºsica)|conciert|band|orquesta|cantante|cantor/)) return 'MÃºsica';\r\n  if (text.match(/teatro|obra|drama|monÃ³logo|monolog/)) return 'Culturales';\r\n  if (text.match(/conferencia|congreso|foro|seminar|seminario|charla/)) return 'Conferencias';\r\n  if (text.match(/deporte|futbol|baloncesto|carrera|maraton|marat[oÃ³]n/)) return 'Deportes';\r\n  // fallback: if tipo field suggests teatro vs musica\r\n  const tipo = (e.tipo || '').toLowerCase();\r\n  if (tipo.includes('mus') || tipo.includes('mÃºsica')) return 'MÃºsica';\r\n  if (tipo.includes('teatro')) return 'Culturales';\r\n  return 'Culturales';\r\n}\r\n\r\nfunction buildEventsIndex(arr) {\r\n  const out = {};\r\n  arr.forEach((raw) => {\r\n    const city = inferCityFromEvent(raw);\r\n    const category = inferCategoryFromEvent(raw);\r\n    // keep original fields but normalize common aliases and ensure url/lugar exist\r\n    const ev = Object.assign({}, raw);\r\n    ev.nombre = raw.nombre || raw.titulo || ev.nombre || '';\r\n    ev.fecha = raw.fecha || ev.fecha || null;\r\n    ev.hora = raw.hora || ev.hora || null;\r\n    ev.lugar = (raw.lugar || raw.ubicacion || ev.lugar || '') || '';\r\n    ev.descripcion = raw.descripcion || raw.summary || ev.descripcion || '';\r\n    ev.url = raw.url || raw.link || ev.url || '';\r\n    out[city] = out[city] || {};\r\n    out[city][category] = out[city][category] || [];\r\n    out[city][category].push(ev);\r\n  });\r\n  return out;\r\n}\r\n\r\n// New: accept two possible source shapes:\r\n// 1) flat array of event objects -> buildEventsIndex(flatArray)\r\n// 2) hierarchical array like the attached `scrapers.json` where each item has\r\n//    { ciudad: 'Name', categoria: 'Cat', eventos: [ ... ] }\r\nfunction buildEventsIndexFromSource(src) {\r\n  // detect hierarchical structure\r\n  if (Array.isArray(src) && src.length > 0 && src[0] && (src[0].ciudad || src[0].categoria) && src[0].eventos) {\r\n    const out = {};\r\n    src.forEach((block) => {\r\n      const city = block.ciudad || capitalizeFirst(block.city || '');\r\n      const category = block.categoria || block.category || 'General';\r\n      out[city] = out[city] || {};\r\n      out[city][category] = out[city][category] || [];\r\n      const list = Array.isArray(block.eventos) ? block.eventos : (block.events || []);\r\n      list.forEach((raw) => {\r\n        const ev = Object.assign({}, raw);\r\n        ev.nombre = raw.nombre || raw.titulo || ev.nombre || '';\r\n        ev.fecha = raw.fecha || ev.fecha || null;\r\n        ev.hora = raw.hora || ev.hora || null;\r\n        ev.lugar = (raw.lugar || raw.ubicacion || ev.lugar || '') || '';\r\n        ev.descripcion = raw.descripcion || raw.summary || ev.descripcion || '';\r\n        ev.url = raw.url || raw.link || ev.url || '';\r\n        out[city][category].push(ev);\r\n      });\r\n    });\r\n    return out;\r\n  }\r\n\r\n  // fallback: flat array of events\r\n  return buildEventsIndex(src || []);\r\n}\r\n\r\nconst eventsData = buildEventsIndexFromSource(scrapedEvents || []);\r\nimport { genId, formatDate, parseIntent, sleep } from '../utils/chatHelpers';\r\n\r\n// NOTE: Do not change selector names or external classes. This module is pure logic.\r\n\r\n// Derivar dinÃ¡micamente las ciudades y categorÃ­as a partir de los datos scrapeados\r\nfunction getCities() {\r\n  return Object.keys(eventsData).sort();\r\n}\r\n\r\nfunction getCategoriesForCity(city) {\r\n  if (!city) return [];\r\n  return Object.keys(eventsData[city] || {}).sort();\r\n}\r\n\r\nexport function useChatBot() {\r\n  const PAGE_SIZE = 5; // configurable page size (mostrar X por acciÃ³n) â€” ahora mostramos varios eventos por peticiÃ³n\r\n\r\n  const [open, setOpen] = useState(true);\r\n  const [state, setState] = useState('idle'); // idle | esperandoCiudad | esperandoCategoria | mostrandoEventos\r\n  const [selectedCity, setSelectedCity] = useState(null);\r\n  const [selectedCategory, setSelectedCategory] = useState(null);\r\n  const [messages, setMessages] = useState(() => [\r\n    { id: genId('msg'), sender: 'ia', text: 'Â¡Hola! Soy tu asistente de eventos â€” encantado de ayudarte. Â¿En quÃ© ciudad te gustarÃ­a buscar?', time: new Date().toISOString() },\r\n  ]);\r\n  const [isTyping, setIsTyping] = useState(false);\r\n\r\n  // pagination index per city|category key\r\n  const [pages, setPages] = useState({});\r\n  // keep a pending city context when bot asked for category but selectedCity may not be set yet\r\n  const [pendingCity, setPendingCity] = useState(null);\r\n\r\n  const pushMessage = useCallback((sender, text) => {\r\n    const msg = { id: genId('msg'), sender, text, time: new Date().toISOString() };\r\n    setMessages((m) => [...m, msg]);\r\n    return msg;\r\n  }, []);\r\n\r\n  // Helper to simulate typing and then send one or multiple bot messages\r\n  const botReply = useCallback((items = [], delay = 600) => {\r\n    // items: array of message objects to push after typing\r\n    (async () => {\r\n      setIsTyping(true);\r\n      // push typing indicator (UI will render the animated dots)\r\n      const typingId = genId('typing');\r\n      setMessages((m) => [...m, { id: typingId, sender: 'ia', type: 'typing', text: 'Un momento, busco lo mejor para ti ðŸ˜Š' }]);\r\n      await sleep(delay);\r\n      // remove typing indicator and append items\r\n      setMessages((prev) => prev.filter((x) => x.id !== typingId).concat(items.map((it) => ({ id: genId('msg'), sender: 'ia', ...it, time: new Date().toISOString() }))));\r\n      setIsTyping(false);\r\n    })();\r\n  }, []);\r\n\r\n  const listCities = useCallback(() => {\r\n    setState('esperandoCiudad');\r\n    // send a text prompt listing cities (conversational, user must type the city name)\r\n    const cities = getCities();\r\n    botReply([\r\n      { text: `Selecciona una ciudad: ${cities.join(', ')}. Escribe el nombre de la ciudad para continuar.` },\r\n    ], 700);\r\n  }, [pushMessage]);\r\n\r\n  const listCategories = useCallback((city) => {\r\n    setState('esperandoCategoria');\r\n    setPendingCity(city);\r\n    const cats = getCategoriesForCity(city);\r\n    const catsText = cats.length ? cats.join(', ') : 'No hay categorÃ­as predefinidas para esta ciudad; puedes escribir palabras como MÃºsica, Teatro, Deportes.';\r\n    botReply([\r\n      { text: `Has seleccionado ${city}. Â¿QuÃ© categorÃ­a quieres ver? ${catsText}. Escribe la categorÃ­a.` },\r\n    ], 700);\r\n  }, [pushMessage]);\r\n\r\n  const showEvents = useCallback((city, category) => {\r\n    setState('mostrandoEventos');\r\n    setSelectedCity(city);\r\n    setSelectedCategory(category);\r\n\r\n    const key = `${city}|${category}`;\r\n  const cityData = eventsData[city] || {};\r\n  const list = cityData[category] || [];\r\n\r\n    // initialize page index if needed\r\n    setPages((p) => ({ ...p, [key]: p[key] ? p[key] : 0 }));\r\n\r\n    if (list.length === 0) {\r\n      botReply([\r\n        { text: `Ups â€” no encuentro ${category} en ${city} ahora mismo. Puedes escribir otra ciudad, otra categorÃ­a, o \"volver\" para reiniciar.` },\r\n      ], 600);\r\n      return;\r\n    }\r\n\r\n    // show PAGE_SIZE items starting from pages[key]\r\n    // read current page index from state (pages may have been initialized above)\r\n    const start = (pages[key] || 0);\r\n    const slice = list.slice(start, start + PAGE_SIZE);\r\n    const items = [];\r\n    // Use a neutral, non-counting intro to avoid revealing small totals.\r\n    items.push({ text: `AquÃ­ tienes algunos eventos en ${category} Â· ${city}:` });\r\n    slice.forEach((ev) => {\r\n      // return the full event object as stored in the index, but format fecha\r\n      const formatted = Object.assign({}, ev);\r\n      try {\r\n        formatted.fecha = formatDate(ev.fecha);\r\n      } catch (err) {\r\n        formatted.fecha = ev.fecha || null;\r\n      }\r\n      items.push({ type: 'event', payload: formatted });\r\n    });\r\n    // guidance for next steps (conversational)\r\n    const guidance = [];\r\n    if (start + PAGE_SIZE < list.length) guidance.push('Si quieres ver mÃ¡s, escribe \"ver mÃ¡s\".');\r\n    guidance.push('Para cambiar de ciudad escribe el nombre de la ciudad. Escribe \"volver\" para volver al inicio.');\r\n    items.push({ text: guidance.join(' ') });\r\n    botReply(items, 800);\r\n  }, [pushMessage]);\r\n  // note: showEvents depends on pages state (used to compute start index). We rely\r\n  // on reading `pages` directly inside the callback so include it in the dependency\r\n  // chain where this hook is recreated when pages changes. To avoid linter noise\r\n  // we could list [pushMessage, pages], but we intentionally keep the body simple\r\n  // and update pages via setPages when advancing. If you see stale page indices,\r\n  // we can refactor to accept an explicit page offset parameter.\r\n\r\n  const handleText = useCallback((text) => {\r\n    if (!text || !text.trim()) return;\r\n    const t = text.trim();\r\n    pushMessage('user', t);\r\n    // use parseIntent from helpers\r\n    const intent = parseIntent(t);\r\n\r\n    // If parser returned a confidence score, use it to decide clarifications\r\n    const confidence = (typeof intent.confidence === 'number') ? intent.confidence : 1.0;\r\n\r\n    // Merge parsed city/category into conversation state (do not overwrite existing unless explicit change requested)\r\n    const parsedCity = intent.city || null;\r\n    const parsedCategory = intent.category || null;\r\n\r\n    // helpers to map parsed tokens into canonical keys used by eventsData\r\n    function mapCity(raw) {\r\n      if (!raw) return null;\r\n      // prefer normalizeCityName if it maps\r\n      const byName = normalizeCityName(raw);\r\n      if (byName && eventsData[byName]) return byName;\r\n      const target = normalizeString(raw);\r\n      for (const k of Object.keys(eventsData)) {\r\n        if (normalizeString(k).startsWith(target)) return k;\r\n      }\r\n      return byName || capitalizeFirst(raw);\r\n    }\r\n\r\n    function mapCategory(raw, cityForLookup) {\r\n      if (!raw) return null;\r\n      // if we have a city, prefer finding a category key within that city\r\n      if (cityForLookup) {\r\n        const found = findCategoryKeyForCity(cityForLookup, raw);\r\n        if (found) return found;\r\n      }\r\n      // otherwise search globally across cities for a matching category key\r\n      const target = normalizeString(raw);\r\n      for (const cityKey of Object.keys(eventsData)) {\r\n        const cats = Object.keys(eventsData[cityKey] || {});\r\n        for (const c of cats) {\r\n          if (normalizeString(c).startsWith(target) || normalizeString(c) === target) return c;\r\n        }\r\n      }\r\n      // fallback: return capitalized raw\r\n      return capitalizeFirst(raw);\r\n    }\r\n\r\n    // Determine mapped values (do not commit to state yet)\r\n    const mappedCity = parsedCity ? mapCity(parsedCity) : null;\r\n    const mappedCategory = parsedCategory ? mapCategory(parsedCategory, mappedCity || selectedCity) : null;\r\n\r\n    // detect explicit change request keywords in user's message (approximate)\r\n    const lowerRaw = (t || '').toLowerCase();\r\n    const explicitChange = /\\b(cambiar|cambio|cambia|nuevo|otra ciudad|otra categoria|otra categorÃ­a|cambiar a)\\b/.test(lowerRaw);\r\n\r\n    // Apply parsed city if we don't have one yet or user explicitly asked to change\r\n    if (mappedCity) {\r\n      if (!selectedCity) {\r\n        setSelectedCity(mappedCity);\r\n      } else if (selectedCity !== mappedCity && explicitChange) {\r\n        setSelectedCity(mappedCity);\r\n      }\r\n    }\r\n\r\n    // Apply parsed category if we don't have one yet or user explicitly asked to change\r\n    if (mappedCategory) {\r\n      if (!selectedCategory) {\r\n        setSelectedCategory(mappedCategory);\r\n      } else if (selectedCategory !== mappedCategory && explicitChange) {\r\n        setSelectedCategory(mappedCategory);\r\n      }\r\n    }\r\n\r\n    // If after applying parsed tokens we have both city and category, perform immediate search\r\n    const finalCity = mappedCity || selectedCity;\r\n    const finalCategory = mappedCategory || selectedCategory;\r\n    if (finalCity && finalCategory) {\r\n      // ensure pagination cursor reset for this pair\r\n      const key = `${finalCity}|${finalCategory}`;\r\n      setPages((p) => ({ ...p, [key]: 0 }));\r\n      setSelectedCity(finalCity);\r\n      setSelectedCategory(finalCategory);\r\n      // Show first event immediately\r\n      botReply([{ text: `Perfecto â€” buscando ${finalCategory} en ${finalCity}...` }], 400);\r\n      // slight delay then show events (showEvents will simulate typing too)\r\n      setTimeout(() => showEvents(finalCity, finalCategory), 600);\r\n      return;\r\n    }\r\n\r\n    // If user typed a city name as free text, map to a known city using eventsData\r\n    if (!mappedCity && !selectedCity) {\r\n      // try to match raw text to a city present in eventsData\r\n      const candidate = Object.keys(eventsData).find(k => normalizeString(k) === normalizeString(t) || normalizeString(k).startsWith(normalizeString(t)));\r\n      if (candidate) {\r\n        // ask for category for that city\r\n        listCategories(candidate);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // If we only have category, ask for city\r\n    if ((mappedCategory || selectedCategory) && !(mappedCity || selectedCity)) {\r\n      const catToAsk = mappedCategory || selectedCategory;\r\n      botReply([{ text: `Â¿En quÃ© ciudad quieres buscar ${catToAsk}? Por ejemplo BogotÃ¡, MedellÃ­n, Cali o Bucaramanga.` }], 500);\r\n      return;\r\n    }\r\n\r\n    // If we only have city, ask for category\r\n    if ((mappedCity || selectedCity) && !(mappedCategory || selectedCategory)) {\r\n      const cityToAsk = mappedCity || selectedCity;\r\n      botReply([{ text: `Genial â€” Â¿quÃ© categorÃ­a te interesa en ${cityToAsk} (por ejemplo MÃºsica, Deportes, Culturales)?` }], 500);\r\n      return;\r\n    }\r\n\r\n    if (intent.intent === 'list_cities') { listCities(); return; }\r\n    // greetings -> friendly human reply and open question\r\n    if (intent.intent === 'greeting') {\r\n      botReply([{ text: 'Â¡Hola! ðŸ˜Š Â¿En quÃ© ciudad te gustarÃ­a buscar eventos o escribe \"buscar <texto>\" para una bÃºsqueda rÃ¡pida?' }], 500);\r\n      return;\r\n    }\r\n    if (intent.intent === 'help') {\r\n      botReply([\r\n        { text: 'Puedo ayudarte a encontrar eventos. Prueba escribir: \"ver ciudades\", \"buscar <texto>\", el nombre de una ciudad (p.e. BogotÃ¡), \"ver mÃ¡s\" o \"volver\" para reiniciar.' }\r\n      ], 600);\r\n      return;\r\n    }\r\n    // user asked to see events -> start the city selection flow\r\n    if (intent.intent === 'list_events') { listCities(); return; }\r\n    if (intent.intent === 'restart') { restart(); return; }\r\n    if (intent.intent === 'show_more') { selectOption('showMore'); return; }\r\n\r\n    if (intent.intent === 'search_query') {\r\n      // show intermediate typing message\r\n      botReply([{ text: `Perfecto â€” busco \"${intent.query}\"...` }], 500);\r\n      // do a search across events and show first match (paged)\r\n      const q = intent.query.toLowerCase();\r\n      const results = [];\r\n      Object.keys(eventsData).forEach((city) => {\r\n        Object.keys(eventsData[city]).forEach((cat) => {\r\n          eventsData[city][cat].forEach((ev) => {\r\n            const hay = `${ev.nombre} ${ev.artista || ''} ${ev.lugar || ''} ${ev.descripcion || ''}`.toLowerCase();\r\n            if (hay.includes(q)) results.push({ city, category: cat, event: ev });\r\n          });\r\n        });\r\n      });\r\n      if (results.length === 0) {\r\n        botReply([{ text: `No encontrÃ© nada para \"${intent.query}\". Â¿Quieres que muestre ciudades, intentes otra bÃºsqueda o pidas ayuda? Escribe ver ciudades, buscar <texto> o ayuda.` }], 800);\r\n      } else {\r\n        // show first found as event (and set pagination state for that city|category)\r\n        const r = results[0];\r\n        const city = capitalizeFirst(r.city);\r\n        const cat = capitalizeFirst(r.category);\r\n        // set pages index so showMore continues in that list\r\n        const key = `${city}|${cat}`;\r\n        setPages((p) => ({ ...p, [key]: 0 }));\r\n        botReply([{ text: `Resultado para \"${intent.query}\" en ${city} â€” ${cat}:` }, { type: 'event', payload: { ...r.event, fecha: formatDate(r.event.fecha) } }, { text: 'Escribe \"ver mÃ¡s\" para ver otro resultado, o \"volver\" para reiniciar.' }], 700);\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (intent.intent === 'search') {\r\n      // robust mapping: normalize keys (remove accents) and match\r\n      const wantedCity = normalizeString(intent.city);\r\n      const wantedCat = normalizeString(intent.category);\r\n      let cityKey = null;\r\n      for (const k of Object.keys(eventsData)) {\r\n        if (normalizeString(k).startsWith(wantedCity)) { cityKey = k; break; }\r\n      }\r\n      let categoryKey = null;\r\n      if (cityKey) {\r\n        categoryKey = findCategoryKeyForCity(cityKey, intent.category) || Object.keys(eventsData[cityKey]).find(k => normalizeString(k).startsWith(wantedCat));\r\n      }\r\n      if (cityKey && categoryKey) {\r\n        // show first event and setup pagination for the proper key names\r\n        const catDisplay = categoryKey;\r\n        const pageKey = `${cityKey}|${catDisplay}`;\r\n        setPages((p) => ({ ...p, [pageKey]: 0 }));\r\n        setSelectedCity(cityKey);\r\n        setSelectedCategory(catDisplay);\r\n        showEvents(cityKey, catDisplay);\r\n      } else {\r\n        const cityPretty = capitalizeFirst(intent.city);\r\n        const catPretty = capitalizeFirst(intent.category);\r\n        botReply([{ text: `Lo siento â€” no tengo toda la info exacta para ${cityPretty} y ${catPretty} ahora mismo. Escribe \"ver ciudades\" para ver opciones o intenta otra bÃºsqueda.` }], 600);\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (intent.intent === 'choose_city') {\r\n      // normalize incoming city name\r\n      const rawCity = intent.city;\r\n      const city = capitalizeFirst(rawCity);\r\n\r\n      // If we already had a selected city, user is switching city mid-conversation\r\n      if (selectedCity && selectedCity !== city) {\r\n        // Attempt to preserve category filter if possible\r\n        if (selectedCategory) {\r\n          const validCat = findCategoryKeyForCity(city, selectedCategory);\r\n          if (validCat) {\r\n            // Reset pagination for new city+category then show first page\r\n            const key = `${city}|${validCat}`;\r\n            setPages((p) => ({ ...p, [key]: 0 }));\r\n            setSelectedCity(city);\r\n            setSelectedCategory(validCat);\r\n            botReply([{ text: `Perfecto â€” ahora busco eventos en ${city}. Mantengo la categorÃ­a ${validCat}.` }], 600);\r\n            // show first item\r\n            showEvents(city, validCat);\r\n            return;\r\n          } else {\r\n            // category not available in new city: inform and offer alternatives\r\n            setSelectedCity(city);\r\n            setSelectedCategory(null);\r\n            const available = getCategoriesForCity(city);\r\n            const options = available.length ? available.concat(['Ver todos']) : ['MÃºsica', 'Culturales', 'Deportes', 'Conferencias'];\r\n            botReply([\r\n              { text: `CambiÃ© a ${city}, pero no encontrÃ© la categorÃ­a ${selectedCategory} allÃ­.` },\r\n                { text: `Puedes elegir otra categorÃ­a: ${options.join(', ')}. Escribe la categorÃ­a que prefieras.` },\r\n            ], 700);\r\n            return;\r\n          }\r\n        }\r\n  // No category to preserve â€” just update city and ask what to do next\r\n  setSelectedCity(city);\r\n  setPendingCity(null);\r\n  const cityCats = getCategoriesForCity(city);\r\n  const catsText = cityCats.length ? cityCats.join(', ') : 'MÃºsica, Culturales, Deportes, Conferencias';\r\n  botReply([{ text: `Perfecto â€” ahora busco eventos en ${city}. Â¿QuÃ© categorÃ­a te interesa? ${catsText}. Escribe la categorÃ­a.` }], 600);\r\n        return;\r\n      }\r\n\r\n      // default behavior (no selectedCity previously): show categories for chosen city\r\n      listCategories(city);\r\n      return;\r\n    }\r\n\r\n    if (intent.intent === 'choose_category') {\r\n      const rawCat = intent.category;\r\n      // find a valid category key in the currently selected city or pendingCity\r\n      const cityForLookup = selectedCity || pendingCity;\r\n      const validCat = cityForLookup ? findCategoryKeyForCity(cityForLookup, rawCat) : null;\r\n      if (validCat && cityForLookup) {\r\n        // reset pagination for this city|category\r\n        const key = `${cityForLookup}|${validCat}`;\r\n        setPages((p) => ({ ...p, [key]: 0 }));\r\n        setSelectedCategory(validCat);\r\n        setSelectedCity(cityForLookup);\r\n        showEvents(cityForLookup, validCat);\r\n      } else if (selectedCity && !validCat) {\r\n        // selected city exists but category not found there\r\n        const available = getCategoriesForCity(selectedCity);\r\n        const options = available.length ? available.concat(['Ver todos']) : ['MÃºsica', 'Culturales', 'Deportes', 'Conferencias'];\r\n        botReply([{ text: `No encontrÃ© la categorÃ­a solicitada en ${selectedCity}. Puedes elegir otra categorÃ­a: ${options.join(', ')}. Escribe la que prefieras.` }], 600);\r\n      } else {\r\n        const cities = getCities();\r\n        botReply([{ text: `Has pedido la categorÃ­a ${capitalizeFirst(rawCat)}. Primero, selecciona una ciudad: ${cities.join(', ')}. Escribe la ciudad.` }], 600);\r\n      }\r\n      return;\r\n    }\r\n    // fallback: use confidence to decide whether to clarify or perform a best-effort\r\n    if (confidence < 0.6) {\r\n      botReply([{ text: 'No estoy seguro de quÃ© quieres decir â€” Â¿Quieres que muestre ciudades, buscar por texto o ver ayuda? Escribe \"ver ciudades\", \"buscar <texto>\" o \"ayuda\".' }], 600);\r\n    } else {\r\n      // try a friendly fallback that asks a clarifying question\r\n      botReply([{ text: 'Â¿Quieres que muestre ciudades, busque por texto o te muestre ayuda? Escribe ver ciudades, buscar <texto> o ayuda.' }], 600);\r\n    }\r\n  }, [listCities, listCategories, pushMessage, selectedCity, showEvents]);\r\n\r\n  \r\n\r\n  // API requested: sendText, selectOption, resetConversation\r\n  const sendText = useCallback((text) => {\r\n    handleText(text);\r\n  }, [handleText]);\r\n\r\n  const selectOption = useCallback((type, value) => {\r\n    // type: 'city'|'category'|'action'|'showMore'\r\n    if (type === 'city') { selectCity(value); return; }\r\n    if (type === 'category') { selectCategory(value); return; }\r\n    if (type === 'action' && (value||'').toLowerCase().includes('volver')) { restart(); return; }\r\n      if (type === 'showMore' || (type === 'action' && (value||'').toLowerCase().includes('ver m'))) {\r\n      // advance pagination for current selection\r\n      const city = selectedCity;\r\n      const category = selectedCategory;\r\n      if (!city || !category) { botReply([{ text: 'Primero selecciona una ciudad y categorÃ­a. Escribe \"ver ciudades\" para ver la lista de ciudades.' }], 500); return; }\r\n      const key = `${city}|${category}`;\r\n      const cityData = eventsData[city] || {};\r\n      const list = cityData[category] || [];\r\n      const current = pages[key] || 0;\r\n      const next = current + PAGE_SIZE;\r\n      if (next >= list.length) {\r\n        botReply([{ text: `No hay mÃ¡s eventos en ${category} para ${city}. Puedes escribir otra categorÃ­a o ciudad, o \"volver\" para reiniciar.` }], 600);\r\n        return;\r\n      }\r\n      // advance page index then show next PAGE_SIZE items\r\n      setPages((p) => ({ ...p, [key]: next }));\r\n      // show events from next index\r\n      const slice = list.slice(next, next + PAGE_SIZE);\r\n      const items = [{ text: `AquÃ­ tienes mÃ¡s eventos en ${category} Â· ${city}:` }];\r\n      slice.forEach((ev) => items.push({ type: 'event', payload: { ...ev, fecha: formatDate(ev.fecha) } }));\r\n      items.push({ text: (next + PAGE_SIZE < list.length) ? 'Escribe \"ver mÃ¡s\" para seguir viendo eventos.' : 'No quedan mÃ¡s eventos en esta lista. Escribe otra categorÃ­a o ciudad, o \"volver\".' });\r\n      botReply(items, 700);\r\n      return;\r\n    }\r\n  }, [listCategories, pushMessage, showEvents, selectedCity, selectedCategory, pages, PAGE_SIZE, botReply]);\r\n\r\n  // helper functions local to hook\r\n  function capitalizeFirst(s) {\r\n    if (!s) return s;\r\n    return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();\r\n  }\r\n\r\n  function normalizeString(s) {\r\n    if (!s) return '';\r\n    return s.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').trim();\r\n  }\r\n\r\n  function normalizeCityName(raw) {\r\n    if (!raw) return raw;\r\n    const r = raw.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\r\n  if (r.startsWith('medell')) return 'MedellÃ­n';\r\n  if (r.startsWith('bogo')) return 'BogotÃ¡';\r\n  if (r.startsWith('cali')) return 'Cali';\r\n  if (r.startsWith('bucara')) return 'Bucaramanga';\r\n  if (r.startsWith('cart') || r.startsWith('cartag')) return 'Cartagena';\r\n  if (r.startsWith('barra') || r.startsWith('barran')) return 'Barranquilla';\r\n    return raw;\r\n  }\r\n\r\n  // find a category key in a city by comparing normalized strings (handles accents)\r\n  function findCategoryKeyForCity(city, catLike) {\r\n    if (!city || !catLike) return null;\r\n    const cityData = eventsData[city] || {};\r\n    const cats = Object.keys(cityData || {});\r\n    const target = catLike.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\r\n    for (const k of cats) {\r\n      const nk = k.toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\r\n      if (nk === target || nk.startsWith(target)) return k;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  const selectCity = useCallback((city) => {\r\n    if (!city) return;\r\n    setSelectedCity(city);\r\n    listCategories(city);\r\n  }, [listCategories]);\r\n\r\n  const selectCategory = useCallback((category) => {\r\n    if (!category) return;\r\n    const cityToUse = selectedCity || pendingCity;\r\n    if (!cityToUse) {\r\n      pushMessage('ia', 'Primero, elige una ciudad para buscar.');\r\n      listCities();\r\n      return;\r\n    }\r\n    // clear pendingCity after consuming\r\n    setPendingCity(null);\r\n    showEvents(cityToUse, category);\r\n  }, [selectedCity, pendingCity, pushMessage, listCities, showEvents]);\r\n\r\n  const restart = useCallback(() => {\r\n    setState('idle');\r\n    setSelectedCity(null);\r\n    setSelectedCategory(null);\r\n    setMessages([{ id: genId('msg'), sender: 'ia', text: 'Â¡Hola de nuevo! Dime en quÃ© ciudad buscas y preparo algunas opciones para ti.', time: new Date().toISOString() }]);\r\n  }, []);\r\n\r\n  const toggleOpen = useCallback(() => setOpen((o) => !o), []);\r\n\r\n  return {\r\n    open,\r\n    state,\r\n    selectedCity,\r\n    selectedCategory,\r\n    messages,\r\n    isTyping,\r\n    // API methods requested\r\n    sendText: sendText,\r\n    selectOption: selectOption,\r\n    resetConversation: restart,\r\n    toggleOpen,\r\n    // legacy actions object for UI compatibility\r\n    actions: {\r\n      pushMessage,\r\n      handleText,\r\n      listCities,\r\n      listCategories,\r\n      selectCity,\r\n      selectCategory,\r\n      showEvents,\r\n      restart,\r\n      toggleOpen,\r\n      // expose newer API on actions for backward compatibility\r\n      selectOption,\r\n      sendText,\r\n      resetConversation: restart,\r\n    },\r\n  };\r\n}\r\n\r\nexport default useChatBot;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}